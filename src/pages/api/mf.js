import axios from 'axios';
import { cache } from '../../utils/cache';
import fs from 'fs';
import path from 'path';

const CACHE_KEY = 'all_schemes_from_api';
const CACHE_KEY_STATUS_INDEX = 'schemes_status_index_v2';
const CACHE_TTL = 6 * 60 * 60 * 1000; // 6 hours cache
const STATUS_INDEX_TTL = 24 * 60 * 60 * 1000; // 24 hours cache for status index

// Load status index from static file
async function loadStatusIndex() {
  // Check cache first
  const cached = cache.get(CACHE_KEY_STATUS_INDEX);
  if (cached) {
    console.log('[STATUS INDEX] Using cached index');
    return cached;
  }

  try {
    // Try to load from public directory (generated by GitHub Actions)
    const filePath = path.join(process.cwd(), 'public', 'fund-status.json');
    
    if (fs.existsSync(filePath)) {
      console.log('[STATUS INDEX] Loading from static file...');
      const fileContent = fs.readFileSync(filePath, 'utf-8');
      const statusIndex = JSON.parse(fileContent);
      
      // Cache it
      cache.set(CACHE_KEY_STATUS_INDEX, statusIndex, STATUS_INDEX_TTL);
      console.log(`[STATUS INDEX] Loaded: ${statusIndex.active.length} active, ${statusIndex.inactive.length} inactive (Updated: ${statusIndex.lastUpdated})`);
      
      return statusIndex;
    } else {
      console.log('[STATUS INDEX] Static file not found, will build on demand');
      return null;
    }
  } catch (error) {
    console.error('[STATUS INDEX] Error loading static file:', error.message);
    return null;
  }
}

// Note: The old buildStatusIndex() and checkSchemeHasGrowth() functions have been removed.
// The system now uses a pre-built static file (public/fund-status.json) generated by:
// - Running: npm run build-index locally, OR
// - GitHub Actions workflow (daily at 2 AM UTC)
// This eliminates the need for real-time API calls and provides instant filtering.

export default async function handler(req, res) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const { page = 1, limit = 20, search = '', status = 'all' } = req.query;
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);

    // Get all schemes from cache or fetch from API
    let allSchemes = cache.get(CACHE_KEY);

    if (!allSchemes) {
      console.log('Fetching schemes from external API...');
      const response = await axios.get('https://api.mfapi.in/mf', {
        timeout: 10000 // 10 second timeout
      });
      allSchemes = response.data;

      // Process and enrich data
      allSchemes = allSchemes.map(scheme => {
        const name = scheme.schemeName || '';
        
        let fundHouse = 'Unknown';
        const parts = name.split('-');
        if (parts.length > 0) {
          fundHouse = parts[0].trim();
        }

        let category = 'Other';
        const nameLower = name.toLowerCase();
        if (nameLower.includes('equity') || nameLower.includes('stock')) {
          category = 'Equity';
        } else if (nameLower.includes('debt') || nameLower.includes('bond')) {
          category = 'Debt';
        } else if (nameLower.includes('hybrid') || nameLower.includes('balanced')) {
          category = 'Hybrid';
        } else if (nameLower.includes('liquid') || nameLower.includes('money market')) {
          category = 'Liquid';
        } else if (nameLower.includes('elss') || nameLower.includes('tax')) {
          category = 'ELSS';
        } else if (nameLower.includes('index') || nameLower.includes('etf')) {
          category = 'Index';
        } else if (nameLower.includes('gilt')) {
          category = 'Gilt';
        }

        return {
          schemeCode: scheme.schemeCode,
          schemeName: name,
          fundHouse: fundHouse,
          category: category
        };
      });

      // Cache the processed data
      cache.set(CACHE_KEY, allSchemes, CACHE_TTL);
      console.log(`Cached ${allSchemes.length} schemes`);
    }

    // Filter by search term first
    let filteredSchemes = allSchemes;
    if (search) {
      const searchLower = search.toLowerCase();
      filteredSchemes = allSchemes.filter(scheme =>
        scheme.schemeName.toLowerCase().includes(searchLower) ||
        scheme.fundHouse.toLowerCase().includes(searchLower) ||
        scheme.category.toLowerCase().includes(searchLower)
      );
    }

    // For active/inactive filter, use pre-built status index
    if (status === 'active' || status === 'inactive') {
      console.log(`[FILTER] Using status index for ${status} filter...`);
      
      // Load status index from static file or cache
      let statusIndex = await loadStatusIndex();
      
      if (!statusIndex) {
        console.error('[FILTER] ERROR: Status index file not found or failed to load!');
        console.error('[FILTER] Expected file: public/fund-status.json');
        console.error('[FILTER] Please run: npm run build-index');
        
        // Return error message to user
        return res.status(503).json({
          error: 'Fund status index not available',
          message: 'Please run: npm run build-index to generate the index file',
          schemes: [],
          pagination: {
            page: 1,
            limit: limitNum,
            total: 0,
            totalPages: 0,
            hasNext: false,
            hasPrev: false
          }
        });
      }
      
      // Filter schemes based on status index
      const activeSet = new Set(statusIndex.active);
      const inactiveSet = new Set(statusIndex.inactive);
      
      const finalFilteredSchemes = filteredSchemes
        .map(scheme => ({
          ...scheme,
          isActive: activeSet.has(scheme.schemeCode)
        }))
        .filter(scheme => 
          status === 'active' ? scheme.isActive : !scheme.isActive
        );
      
      console.log(`[FILTER] Filtered ${finalFilteredSchemes.length} ${status} funds from ${filteredSchemes.length} total`);
      
      // Apply pagination to filtered results
      const total = finalFilteredSchemes.length;
      const totalPages = Math.ceil(total / limitNum);
      const startIndex = (pageNum - 1) * limitNum;
      const endIndex = startIndex + limitNum;
      const paginatedSchemes = finalFilteredSchemes.slice(startIndex, endIndex);
      
      res.status(200).json({
        schemes: paginatedSchemes,
        pagination: {
          page: pageNum,
          limit: limitNum,
          total: total,
          totalPages: totalPages,
          hasNext: pageNum < totalPages,
          hasPrev: pageNum > 1
        }
      });
    } else {
      // For 'all' status, use normal pagination
      const total = filteredSchemes.length;
      const totalPages = Math.ceil(total / limitNum);
      const startIndex = (pageNum - 1) * limitNum;
      const endIndex = startIndex + limitNum;
      const paginatedSchemes = filteredSchemes.slice(startIndex, endIndex);

      // Load status index to add isActive field to schemes
      const statusIndex = await loadStatusIndex();
      let schemesWithStatus = paginatedSchemes;
      
      if (statusIndex) {
        const activeSet = new Set(statusIndex.active);
        schemesWithStatus = paginatedSchemes.map(scheme => ({
          ...scheme,
          isActive: activeSet.has(scheme.schemeCode)
        }));
      } else {
        // If no status index, default to undefined (frontend can handle it)
        schemesWithStatus = paginatedSchemes.map(scheme => ({
          ...scheme,
          isActive: undefined
        }));
      }

      res.status(200).json({
        schemes: schemesWithStatus,
        pagination: {
          page: pageNum,
          limit: limitNum,
          total: total,
          totalPages: totalPages,
          hasNext: pageNum < totalPages,
          hasPrev: pageNum > 1
        }
      });
    }
  } catch (error) {
    console.error('Error fetching schemes:', error);
    res.status(500).json({ error: 'Failed to fetch mutual fund schemes' });
  }
}
